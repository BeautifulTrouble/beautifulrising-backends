#!/usr/bin/env python3

import autovenv
autovenv.run()

import json
import os
import sys
from subprocess import Popen
from urllib.parse import urlparse, unquote

import couchdb
from couchdb.http import ResourceNotFound
from flask import Flask, Response, request, url_for
from flask_restful import Resource, Api
from werkzeug.exceptions import NotFound, Forbidden

from utils import *


PORT = 6000
PREFIX = 'api/v1'
GOOGLE_VERIFICATION = 'google5844dd3c739be066.html'


app = Flask(__name__)
api = Api(app)

couch = couchdb.Server()
db = couch['toolbox']


class CouchDocumentAccessor(object):
    def __init__(self, id):
        self.id = id
    def __getitem__(self, item):
        return db[self.id].get(item, '')
    def items(self):
        return db[self.id].items()
config = CouchDocumentAccessor('config:api')


def flatten_args(args, sep=','):
    '''
    Flatten a werkzeug MultiDict containing duplicate, optionally comma-
    separated query parameters to a dictionary of lists without duplicates
        e.g.:     "?name=foo&tags=a,b&tags=c,d&tags=d"
        becomes:  {'name': ['foo'], 'tags': ['a', 'c', 'b', 'd']}
    '''
    return {k: list({i for splitL in (L.split(sep) for L in args.getlist(k)) for i in splitL})
            for k in args}


def header(name):
    '''
    Always get a string, even for missing headers
    '''
    return request.headers.get(name, '')


@app.after_request
def add_cors_headers(response):
    '''
    Tell browsers it's okay to load from this resource
    '''
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
    response.headers.add('Access-Control-Allow-Methods', 'GET')
    return response


@app.route('/' + GOOGLE_VERIFICATION)
def google_verification():
    '''
    Keep the googles happy
    '''
    return 'google-site-verification: {}'.format(GOOGLE_VERIFICATION)


@app.route(urlparse(config['notification-url']).path, methods=['POST'])
def notify():
    '''
    Invoke content loader upon change notification
    '''
    # Before doing anything, verify the notification token
    if header('X-Goog-Channel-Token') != config['notification-token']:
        raise Forbidden

    state = header('X-Goog-Resource-State')
    channel_id = header('X-Goog-Channel-Id')
    resource_id = header('X-Goog-Resource-Id')

    # Save new notification ids so they can be cancelled
    if state == 'sync':
        log("sync: Channel-Id: {} Resource-Id: {}".format(channel_id, resource_id))
        try:
            channels = db['config:notification-channels']
            channels[channel_id] = resource_id
        except ResourceNotFound:
            channels = {channel_id: resource_id}
            channels.update(_id='config:notification-channels')
        db.save(channels)

    # Notify that a document is no longer in the collection
    # TODO: new document tracking system by id
    elif state == 'delete':
        print('delete', request.get_json())
        # XXX: pid = Popen([sys.executable, "contentloader", "--delete-id", doc_id]).pid

    # Attempt to invoke the content loader
    elif state == 'change':
        log("change: Channel-Id: {} Resource-Id: {}".format(channel_id, resource_id))
        body = request.get_json()
        if body:
            with script_directory():
                change_number = str(int(body['id']))
                # Using sys.executable ensures the virtualenv currently in effect 
                # for this server will also be used for the contentloader tool.
                pid = Popen([sys.executable, "contentloader", "--change-id", change_number]).pid

    # 204 No Content (success)
    return ('', 204)


def filter_by_language(resources, args):
    '''
    Filter a collection of resources down to a single language
    '''
    language_all = config['language-all']
    language_add = config['language-add']
    language_default = config['language-default']
    language_remove = config['language-remove']

    # Get one valid language no matter what
    lang = ((set(language_all) & set(args.get('lang', ()))) or {language_default}).pop()

    output = []
    for resource in resources:
        if 'translations' in resource:
            # In the default language simply removing the translations is enough
            translations = resource.pop('translations')
            # In translated languages merge data using language-add and language-remove config items
            if lang in translations:
                preserved = {k:v for k,v in resource.items() if k in language_add}
                resource.update({k:v for k,v in translations[lang].items() if k not in language_remove})
                for k,item_in_default_language in preserved.items():
                    if isinstance(resource[k], list) and isinstance(item_in_default_language, list):
                        resource[k] += item_in_default_language
                resource['lang'] = lang
        output.append(resource)
    return output


# Get content types and create endpoints
types = {slugify(T['one']): slugify(T['many']) for T in config['types']}
for singular_name,plural_name in types.items():
    class Many(Resource):
        type = singular_name
        query = "function(doc){if(doc.type=='%s'){emit(doc.slug,doc)}}" % singular_name
        def get(self):
            args = flatten_args(request.args)
            try:
                resources = [doc['value'] for doc in db.query(self.query)]
            except (KeyError, ResourceNotFound): raise NotFound
            return filter_by_language(resources, args)
    api.add_resource(Many, '/{PREFIX}/{plural_name}'.format(**vars()), endpoint=plural_name)


    class One(Resource):
        type = singular_name
        def get(self, id):
            args = flatten_args(request.args)
            try:
                resource = db['{}:{}'.format(self.type, id)]
            except ResourceNotFound: raise NotFound
            return filter_by_language([resource], args)[0]
    api.add_resource(One, '/{PREFIX}/{singular_name}/<id>'.format(**vars()), endpoint=singular_name)


# Get the grouped types and create endpoints
groups = {k.split('-',1)[-1]:[slugify(d['one']) for d in v] for k,v in config.items() if k.startswith('types-')}
for group,types in groups.items():
    class Group(Resource):
        types = types
        query = "function(doc){if(%s.indexOf(doc.type)!=-1){emit(doc.slug,doc)}}" % json.dumps(types)
        def get(self):
            args = flatten_args(request.args)
            try:
                resources = [doc['value'] for doc in db.query(self.query)]
            except (KeyError, ResourceNotFound): raise NotFound
            return filter_by_language(resources, args)
    api.add_resource(Group, '/{PREFIX}/{group}'.format(**vars()), endpoint=group)


# Just emit all the documents
class All(Resource):
    query = "function(doc){emit(doc.slug,doc)}"
    def get(self):
        args = flatten_args(request.args)
        try:
            resources = [doc['value'] for doc in db.query(self.query)]
        except (KeyError, ResourceNotFound): raise NotFound
        return filter_by_language(resources, args)
api.add_resource(All, '/{PREFIX}/all'.format(**vars()), endpoint='all')


# Expose the config for front-ends
class Config(Resource):
    def get(self):
        return {k:v for k,v in config.items() if k not in config['config-hidden-keys']}
api.add_resource(Config, '/{PREFIX}/config'.format(**vars()))


# Expose the endpoints
class Endpoints(Resource):
    def get(self):
        return {rule.endpoint: {
                'url': unquote(url_for(rule.endpoint, **{a: '[{}]'.format(a) for a in rule.arguments})),
                'methods': list(rule.methods),
            } for rule in app.url_map.iter_rules()}
api.add_resource(Endpoints, '/'.format(**vars()))


if __name__ == '__main__':
    app.run(port=PORT, debug='--debug' in sys.argv)

