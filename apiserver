#!/usr/bin/env python3
#encoding: utf-8

import autovenv
autovenv.run()

import json
import os
import sys
from urllib.parse import urlparse, unquote

import couchdb
from couchdb.http import ResourceNotFound
from flask import Flask, Response, request, url_for
from flask_restful import Resource, Api
from flask_compress import Compress
from werkzeug.exceptions import NotFound, Forbidden

from utils import *
from config import *


# App Setup
# ////////////////////////////////////////////////////////////////////////////
app = Flask(__name__)
api = Api(app)
Compress(app)


# CouchDB Setup
# ////////////////////////////////////////////////////////////////////////////
couch = couchdb.Server()
db = couch[DB_NAME]


class CouchDocumentAccessor(object):
    def __init__(self, id):
        self.id = id
    def __getitem__(self, item):
        return db[self.id].get(item, '')
    def items(self):
        return db[self.id].items()
config = CouchDocumentAccessor('config:api')


# Google administrative mumbo jumbo
# ////////////////////////////////////////////////////////////////////////////
def recaptcha_is_valid():
    '''
    Validate a properly implemented front-end recaptcha form
    '''
    return requests.post('https://www.google.com/recaptcha/api/siteverify', data={
        'secret': RECAPTCHA_SITE_SECRET,
        'response': request.form.get('g-recaptcha-response'),
        'remoteip': request.remote_addr,
    }).json().get('success')


@app.route('/' + GOOGLE_VERIFICATION)
def google_verification():
    '''
    Keep the googles happy
    '''
    return 'google-site-verification: {}'.format(GOOGLE_VERIFICATION)


# Drive change notification
# ////////////////////////////////////////////////////////////////////////////
@app.route(urlparse(config['notification-url']).path, methods=['POST'])
def notify():
    '''
    Invoke content loader upon change notification
    '''
    header = lambda name: request.headers.get(name, '')

    # Before doing anything, verify the notification token
    if header('X-Goog-Channel-Token') != config['notification-token']:
        raise Forbidden

    state = header('X-Goog-Resource-State')
    channel_id = header('X-Goog-Channel-Id')
    resource_id = header('X-Goog-Resource-Id')

    # Save new notification ids so they can be cancelled
    if state == 'sync':
        log("sync: Channel-Id: {} Resource-Id: {}".format(channel_id, resource_id))
        try:
            channels = db['config:notification-channels']
            channels[channel_id] = resource_id
        except ResourceNotFound:
            channels = {channel_id: resource_id}
            channels.update(_id='config:notification-channels', type='config', slug='notification-channels')
        db.save(channels)

    # Notify that a document is no longer in the collection
    # TODO: new document tracking system by id
    elif state == 'delete':
        print('delete', request.get_json())
        # XXX: venv_run("contentloader", "--delete-id", doc_id)

    # Attempt to invoke the content loader
    elif state == 'change':
        log("changed: Channel-Id: {} Resource-Id: {}".format(channel_id, resource_id))
        body = request.get_json()
        if body:
            with script_directory():
                change_number = str(int(body['id']))
                venv_run("contentloader", "--change-id", change_number)

    # 204 No Content (success)
    return ('', 204)


# Language filtering
# ////////////////////////////////////////////////////////////////////////////
def filter_by_language(resources, args):
    '''
    Filter a collection of resources down to a single language
    '''
    language_all = config['language-all']
    language_add = config['language-add']
    language_default = config['language-default']
    language_remove = config['language-remove']

    # Get one valid language no matter what
    lang = ((set(language_all) & set(args.get('lang', ()))) or {language_default}).pop()

    output = []
    for resource in resources:
        # In the default language simply removing the translations is enough
        translations = resource.pop('translations', {})
        if translations:
            # In translated languages merge data using language-add and language-remove config items
            if lang in translations:
                preserved = {k:v for k,v in resource.items() if k in language_add}
                resource.update({k:v for k,v in translations[lang].items() if k not in language_remove})
                for k,item_in_default_language in preserved.items():
                    # Merge one level of nested lists
                    if isinstance(resource[k], list) and isinstance(item_in_default_language, list):
                        resource[k] += [item for item in item_in_default_language if item not in resource[k]]
                resource['lang'] = lang
        # List available languages
        resource['languages'] = list(translations.keys() | {language_default})
        output.append(resource)
    return output


# API Endpoints
# ////////////////////////////////////////////////////////////////////////////
def flatten_args(args, sep=','):
    '''
    Flatten a werkzeug MultiDict containing duplicate, optionally comma-
    separated query parameters to a dictionary of lists without duplicates
        e.g.:     "?name=foo&tags=a,b&tags=c,d&tags=d"
        becomes:  {'name': ['foo'], 'tags': ['a', 'c', 'b', 'd']}
    '''
    return {k: list({i for splitL in (L.split(sep) for L in args.getlist(k)) for i in splitL})
            for k in args}


@app.after_request
def add_cors_headers(response):
    '''
    Tell browsers it's okay to load from this resource
    '''
    response.headers.add('Access-Control-Allow-Origin', '*')
    response.headers.add('Access-Control-Allow-Headers', 'Content-Type,Authorization')
    response.headers.add('Access-Control-Allow-Methods', 'GET')
    return response


# Get content types and create endpoints
types = {slugify(T['one']): slugify(T['many']) for T in config['types']}
for singular_name,plural_name in types.items():

    class Many(Resource):
        type = singular_name
        query = "function(doc){if(doc.type=='%s'){emit(doc.slug,doc)}}" % singular_name
        def get(self):
            args = flatten_args(request.args)
            try:
                resources = [doc['value'] for doc in db.query(self.query)]
            except (KeyError, ResourceNotFound): raise NotFound
            return filter_by_language(resources, args)
    api.add_resource(Many, '/{API_PREFIX}/{plural_name}'.format(**vars()), endpoint=plural_name)

    class One(Resource):
        type = singular_name
        def get(self, id):
            args = flatten_args(request.args)
            try:
                resource = db['{}:{}'.format(self.type, id)]
            except ResourceNotFound: raise NotFound
            return filter_by_language([resource], args)[0]
    api.add_resource(One, '/{API_PREFIX}/{singular_name}/<id>'.format(**vars()), endpoint=singular_name)


# Get the grouped types and create endpoints
groups = {k.split('-',1)[-1]:[slugify(d['one']) for d in v] for k,v in config.items() if k.startswith('types-')}
for group,types in groups.items():

    class Group(Resource):
        types = types
        query = "function(doc){if(%s.indexOf(doc.type)!=-1){emit(doc.slug,doc)}}" % json.dumps(types)
        def get(self):
            args = flatten_args(request.args)
            try:
                resources = [doc['value'] for doc in db.query(self.query)]
            except (KeyError, ResourceNotFound): raise NotFound
            return filter_by_language(resources, args)
    api.add_resource(Group, '/{API_PREFIX}/{group}'.format(**vars()), endpoint=group)


# Just emit all the documents
class All(Resource):
    query = "function(doc){emit(doc.slug,doc)}"
    def get(self):
        args = flatten_args(request.args)
        try:
            resources = [doc['value'] for doc in db.query(self.query)]
        except (KeyError, ResourceNotFound): raise NotFound
        return filter_by_language(resources, args)
api.add_resource(All, '/{API_PREFIX}/all'.format(**vars()), endpoint='all')


# Expose the config for front-ends
class Config(Resource):
    def get(self):
        return {k:v for k,v in config.items() if k not in config['config-hidden-keys']}
api.add_resource(Config, '/{API_PREFIX}/config'.format(**vars()))


# Expose the endpoints themselves
class Endpoints(Resource):
    def get(self):
        return {rule.endpoint: {
                'url': unquote(url_for(rule.endpoint, **{a: '[{}]'.format(a) for a in rule.arguments})),
                'methods': list(rule.methods),
            } for rule in app.url_map.iter_rules()}
api.add_resource(Endpoints, '/'.format(**vars()))


# Run when invoked from the command line
# ////////////////////////////////////////////////////////////////////////////
if __name__ == '__main__':
    app.run(port=6000, debug='--debug' in sys.argv)


